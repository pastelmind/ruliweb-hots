#!/usr/bin/env node

/**
 * @file Merge data from JSON files generated by HeroesDataParser into
 * ruliweb-hots' own JSON file.
 * Note: To use HeroesDataParser, you should use the `-l koKR` option.
 */

// Currently, there is no way to check if an ESM module is the CLI entrypoint in
// Node.js. Because of this, I had to extract hdp-parser.js as a separate module
// just so that I could test it.
// Node.js devs seem to be toying with the idea of supporting a
// `import.meta.main` property, which would enable this.
// See discussion on https://github.com/nodejs/modules/issues/274

import { promises as fsPromises } from "fs";
import path from "path";
import { fileURLToPath } from "url";

import program from "commander";

import {
  createHdpHeroDataKoSchema,
  loadHdpHeroDataSchema,
  loadHotsSchema,
} from "../scripts/schemas.js";

import { parseHotsData } from "./src/hdp-parser.js";
import { deepEqual } from "./src/lazy-assert.js";
import { createMergedHotsData } from "./src/merge-hots-data.js";
import { ValidatorFactory } from "./src/validators.js";

const { readFile, writeFile } = fsPromises;

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const DEFAULT_JSON_PATH = path.join(__dirname, "../docs/hots.json");

program
  .arguments("<json_kr> <json_en>")
  .on("--help", () => {
    console.log("\n  Arguments:\n");
    console.log(
      "    <json_kr>".padEnd(32) +
        "  JSON file (koKR) generated by HeroesDataParser"
    );
    console.log(
      "    <json_en>".padEnd(32) +
        "  JSON file (enUS) generated by HeroesDataParser"
    );
  })
  .option(
    "-m, --merge-json [jsonfile]",
    "hots.json file to merge with",
    DEFAULT_JSON_PATH
  )
  .option(
    "-o, --output-json [jsonfile]",
    "hots.json file to write to",
    DEFAULT_JSON_PATH
  )
  .option("-p, --ptr", "Prioritize merging into heroes in PTR section")
  .action((jsonKr, jsonEn) => {
    if (jsonKr) program.jsonKr = path.resolve(jsonKr);
    if (jsonEn) program.jsonEn = path.resolve(jsonEn);
  })
  .parse(process.argv);

if (process.argv.length <= 2 || !program.jsonKr) {
  console.error("Must specify HeroesDataParser output JSON file (koKR)");
  program.help();
}

if (!program.jsonEn) {
  console.error("Must specify HeroesDataParser output JSON file (enUS)");
  program.help();
}

(async () => {
  let isAborted = false;

  /**
   * @param {string} fileName
   * @return {Promise<*>}
   */
  async function loadJson(fileName) {
    const fileContent = await readFile(fileName, "utf8");
    if (isAborted) return;

    return JSON.parse(fileContent);
  }

  try {
    const [jsonKo, jsonEn, schemaEn, hotsSchema, hotsData] = await Promise.all([
      loadJson(program.jsonKr),
      loadJson(program.jsonEn),
      loadHdpHeroDataSchema(),
      loadHotsSchema(),
      (async () => JSON.parse(await readFile(program.mergeJson, "utf8")))(),
    ]);

    const schemaKo = createHdpHeroDataKoSchema(schemaEn);
    const vf = new ValidatorFactory();
    const validatorEn = vf.createHdpHeroDataValidator(schemaEn);
    const validatorKo = vf.createHdpHeroDataKoValidator(schemaKo);

    if (!validatorKo.validate(jsonKo)) {
      console.error("Invalid Korean JSON file:", program.jsonKr);
      throw validatorKo.errors();
    }
    if (!validatorEn.validate(jsonEn)) {
      console.error("Invalid English JSON file:", program.jsonEn);
      throw validatorEn.errors();
    }

    deepEqual(
      new Set(Object.keys(jsonKo)),
      new Set(Object.keys(jsonEn)),
      "Korean and English data do not have matching hero keys"
    );

    const heroes = parseHotsData(jsonEn, jsonKo);

    const hotsValidator = vf.createHotsValidator(hotsSchema);
    if (!hotsValidator.validate(hotsData)) {
      console.error("Merge source is invalid hots.json:", program.mergeJson);
      throw hotsValidator.errors();
    }

    const mergedData = createMergedHotsData(hotsData, { heroes });
    await writeFile(program.outputJson, JSON.stringify(mergedData, null, 2));
  } catch (e) {
    isAborted = true;
    console.error(e);
    process.exitCode = 1;
  }
})();
