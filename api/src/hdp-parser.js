/**
 * @file Tools for parsing herodata.json generated by HeroesDataParser.
 * @see https://github.com/koliva8245/HeroesDataParser
 */

import {
  findAbilitiesByIds,
  findAbilityById,
  findAllAbilitiesByTypes,
} from "./hdp-find.js";
import { parseHeroStats } from "./hdp-parser-stats.js";
import {
  extractAbilityCostFragment,
  extractCooldownFragment,
  parseShortTooltip,
  parseTooltip,
} from "./hdp-parser-tooltip.js";
import { assert, equal, fail, throws } from "./lazy-assert.js";
import {
  _c,
  isKeyOf,
  isNotNullish,
  isNullish,
  objectEntries,
} from "./type-util.js";

/**
 * @typedef {import("../../generated-types/hdp-herodata-ko").AbilityKo} HdpAbilityKo
 * @typedef {import("../../generated-types/hdp-herodata-ko").HdpHeroDataKo} HdpHeroDataKo
 * @typedef {import("../../generated-types/hdp-herodata-ko").HeroKo} HdpHeroKo
 * @typedef {import("../../generated-types/hdp-herodata-ko").TalentKo} HdpTalentKo
 * @typedef {import("../../generated-types/hdp-herodata").Ability} HdpAbilityEn
 * @typedef {import("../../generated-types/hdp-herodata").AbilityType} HdpAbilityType
 * @typedef {import("../../generated-types/hdp-herodata").HdpHeroData} HdpHeroDataEn
 * @typedef {import("../../generated-types/hdp-herodata").Hero} HdpHeroEn
 * @typedef {import("../../generated-types/hdp-herodata").Talent} HdpTalentEn
 * @typedef {import("../../generated-types/hots").Hero} Hero
 * @typedef {import("../../generated-types/hots").RuliwebHotSDataset} RuliwebHotSDataset
 * @typedef {import("../../generated-types/hots").Skill} Skill
 * @typedef {import("../../generated-types/hots").Talent} Talent
 */

/**
 * @typedef {Skill["type"]} SkillType
 * @typedef {Talent["upgradeFor"]} UpgradeForType
 */

/**
 * Parses JSON data generated by HeroesDataParser and converts it to a
 * collection of Ruliweb-Hots Hero objects.
 * @param {Readonly<HdpHeroDataEn>} hdpHeroDataEn
 * @param {Readonly<HdpHeroDataKo>} hdpHeroDataKo
 * @return {Record<string, Hero>} New collection of Hero objects, sorted
 *    alphabetically by ID
 */
export function parseHotsData(hdpHeroDataEn, hdpHeroDataKo) {
  /** @type {Record<string, Hero>} */
  const heroes = {};

  // Sort heroes by ID alphabetically
  for (const heroId of Object.keys(hdpHeroDataKo).sort()) {
    const hdpHeroEn = hdpHeroDataEn[heroId];
    const hdpHeroKo = hdpHeroDataKo[heroId];
    assert(hdpHeroEn, "Missing hero %o in HDP English data", heroId);
    assert(hdpHeroKo, "Missing hero %o in HDP Korean data", heroId);

    heroes[heroId] = parseHero(heroId, hdpHeroEn, hdpHeroKo);
  }

  // Copy Cho's stats to Gall
  if (
    Object.prototype.hasOwnProperty.call(heroes, "Cho") &&
    Object.prototype.hasOwnProperty.call(heroes, "Gall")
  ) {
    const cho = heroes["Cho"];
    const gall = heroes["Gall"];
    assert(!Array.isArray(cho.stats));
    assert(!Array.isArray(gall.stats));

    gall.stats.hp = { ...cho.stats.hp };
    gall.stats.radius = cho.stats.radius;
    gall.stats.speed = cho.stats.speed;
    gall.stats.hpRegen = { ...cho.stats.hpRegen };
  }

  return heroes;
}

/**
 * Convenience type for passing HDP hero objects between functions.
 * @typedef {object} HeroPack
 * @property {string} id Hero ID
 * @property {HdpHeroEn} en
 * @property {HdpHeroKo} ko
 */

const HERO_ROLES = {
  Bruiser: _c("bruiser"),
  Healer: _c("healer"),
  "Melee Assassin": _c("melee_assassin"),
  "Ranged Assassin": _c("ranged_assassin"),
  Support: _c("support"),
  Tank: _c("tank"),
};

const HERO_UNIVERSES = {
  Classic: _c("classic"),
  Diablo: _c("diablo"),
  Nexus: _c("nexus"),
  Overwatch: _c("overwatch"),
  Starcraft: _c("starcraft"),
  Warcraft: _c("warcraft"),
};

/**
 * @param {string} heroId
 * @param {HdpHeroEn} heroEn
 * @param {HdpHeroKo} heroKo
 * @return {Hero}
 */
export function parseHero(heroId, heroEn, heroKo) {
  equal(heroEn.unitId, heroKo.unitId);
  assert(
    isKeyOf(heroEn.expandedRole, HERO_ROLES),
    "Unexpected hero role: %o in %o",
    heroEn.expandedRole,
    heroId
  );
  assert(
    isKeyOf(heroEn.franchise, HERO_UNIVERSES),
    "Unexpected hero franchise: %o in %o",
    heroEn.franchise,
    heroId
  );

  const hero = { id: heroId, en: heroEn, ko: heroKo };

  const abilitiesEn = Object.values(heroEn.abilities)
    .filter(isNotNullish)
    .flat()
    .filter((ability) => shouldIncludeAbility(ability, heroId));
  const abilitiesKo = Object.values(heroKo.abilities)
    .filter(isNotNullish)
    .flat()
    .filter((ability) => shouldIncludeAbility(ability, heroId));

  /** @type {Skill[]} */
  const skills = [
    ...abilitiesEn.map((abilityEn, index) =>
      parseSkillTalent(abilityEn, abilitiesKo[index])
    ),
    ...parseAdditionalSkills(hero),
  ];

  skills.sort((skillA, skillB) => {
    const priorityA = getSkillSortPriority(skillA, heroId);
    const priorityB = getSkillSortPriority(skillB, heroId);
    // Higher priority appears first (descending order)
    return priorityB - priorityA || skillA.type.localeCompare(skillB.type);
  });

  /** @type {Record<string, Talent[]>} */
  const talents = {};
  for (const [tier, talentArray] of objectEntries(heroEn.talents)) {
    const match = tier.match(/^level(\d+)$/);
    assert(match, "Unexpected talent tier: %o in %o", tier, heroId);

    let level = Number(match[1]);
    // Fix for Chromie's trait
    if (heroId === "Chromie") level = Math.max(1, level - 2);

    talents[level] = talentArray.map((hdpTalentEn, index) =>
      parseTalent(hdpTalentEn, heroKo.talents[tier][index])
    );
  }
  insertAdditionalTalents(hero, talents);

  return {
    name: heroKo.name,
    title: heroKo.title,
    icon: iconNameToId(heroEn.portraits.target),
    newRole: HERO_ROLES[heroEn.expandedRole],
    universe: HERO_UNIVERSES[heroEn.franchise],
    stats: parseHeroStats(heroId, heroEn, heroKo),
    skills,
    talents,
  };
}

/**
 * Provides a sort priority for skill types. Higher values will appear first.
 * Skill types not listed here have a priority of 0.
 * Skill types with the same priority are sorted alphabetically by type.
 */
const SKILL_TYPE_SORT_PRIORITY = /** @type {ReadonlyMap<SkillType, number>}} */ (makeReadonlyMap(
  {
    D: 700,
    "D - Q": 690,
    "D - W": 680,
    "D - E": 670,
    "D - active": 660,
    Q: 600,
    "Q - Q": 590,
    "Q - W": 580,
    "Q - E": 570,
    W: 500,
    E: 400,
    R: 300,
    active: 200,
    Z: 100,
    "Z - Q": 90,
    "Z - W": 80,
  }
));

/**
 * Returns the sort priority of the skill.
 * @param {Skill} skill
 * @param {string} heroId
 * @return {number}
 */
function getSkillSortPriority(skill, heroId) {
  // Special cases
  switch (heroId) {
    case "DVa":
      // Put all Pilot Mode skills after all Mech Mode skills
      if (skill.id === "DVaPilotPilotMode" || skill.id === "DVaPilotCallMech") {
        return (SKILL_TYPE_SORT_PRIORITY.get(skill.type) || 0) - 1000;
      }
      break;
    case "Greymane":
      if (skill.type === "D - Q") {
        return (SKILL_TYPE_SORT_PRIORITY.get("Q") || 0) - 5;
      }
      if (skill.type === "D - E") {
        return (SKILL_TYPE_SORT_PRIORITY.get("E") || 0) - 5;
      }
      break;
    case "Stitches":
      if (skill.type === "active") {
        equal(skill.id, "StitchesHookHelpingHand", "Unexpected active skill");
        return (SKILL_TYPE_SORT_PRIORITY.get("Q") || 0) - 5;
      }
      break;
    case "Tinker":
      if (skill.type === "active") {
        equal(skill.id, "TinkerFocusTurrets", "Unexpected active skill");
        return (SKILL_TYPE_SORT_PRIORITY.get("Q") || 0) - 5;
      }
      break;
  }

  return SKILL_TYPE_SORT_PRIORITY.get(skill.type) || 0;
}

/**
 * Determines if the ability should be included or ignored.
 * @param {HdpAbilityEn | HdpAbilityKo} ability
 * @param {string} heroId
 * @return {boolean}
 */
function shouldIncludeAbility(ability, heroId) {
  switch (ability.abilityType) {
    case "Q":
    case "W":
    case "E":
      // The Lost Vikings unlock their Q/W/E via talents
      return heroId !== "LostVikings";
    case "B":
      equal(ability.nameId, "Hearthstone", `Unexpected hearthstone ability`);
      return false;
    case "Spray":
      equal(ability.nameId, "LootSpray", `Unexpected spray ability`);
      return false;
    case "Voice":
      equal(ability.nameId, "LootYellVoiceLine", `Unexpected voice ability`);
      return false;
    case "Heroic":
      // Heroes that have heroic abilities at start of game
      return heroId === "Deathwing" || heroId === "Tracer";
    case "Z":
      return !(ability.nameId === "Mount" || ability.nameId === "Dismount");
    case "Active":
      // Samuro unlocks his active abilities (select self/select all) via his
      // heroic ability
      if (heroId === "Samuro") return false;
      // For Lost Vikings, include Select Erik/Baleog/Olaf only
      if (heroId === "LostVikings") {
        return ability.nameId !== "LostVikingSelectAll";
      }
  }

  return true;
}

/**
 * Maps (parent skill type, child skill type) to a child skill subtype.
 */
const PARENT_SKILL_TYPE_TO_SUBTYPE = makeReadonlyMap({
  D: makeReadonlyMap({
    Q: _c("D - Q"),
    W: _c("D - W"),
    E: _c("D - E"),
    active: _c("D - active"),
  }),
  Q: makeReadonlyMap({
    Q: _c("Q - Q"),
    W: _c("Q - W"),
    E: _c("Q - E"),
  }),
  R: makeReadonlyMap({
    Q: _c("R - Q"),
    W: _c("R - W"),
    E: _c("R - E"),
  }),
  Z: makeReadonlyMap({
    Q: _c("Z - Q"),
    W: _c("Z - W"),
  }),
});

/**
 * Updates the type of the skill as the subtype of a parent skill.
 * @template {Skill | Talent} T
 * @param {SkillType} parentSkillType
 * @param {T} skill
 * @return {T} The modified skill (for convenience)
 * @throws If the skill type cannot be converted to a subtype of a trait
 */
function convertSkillTypeToSubtypeOf(parentSkillType, skill) {
  const skillTypeToSubType = PARENT_SKILL_TYPE_TO_SUBTYPE.get(parentSkillType);
  assert(
    skillTypeToSubType,
    "Skill %o cannot be converted to a subtype of %o, because a skill of %o cannot have child skills",
    skill.id,
    parentSkillType,
    parentSkillType
  );

  const childType = skillTypeToSubType.get(skill.type);
  assert(
    childType,
    "Skill %o has type %o, which cannot be converted to a subtype of %o",
    skill.id,
    skill.type,
    parentSkillType
  );

  skill.type = childType;
  return skill;
}

/**
 * Parses additional skills from a hero's subabilities or hero units.
 * @param {HeroPack} hero
 * @return {Skill[]}
 */
function parseAdditionalSkills(hero) {
  switch (hero.id) {
    case "Abathur":
      return parseHeroUnitAbilitiesOfType(hero, ["Q", "W", "E"]).map(
        convertSkillTypeToSubtypeOf.bind(null, "Q")
      );
    case "Alexstrasza":
    case "Ragnaros":
      return parseHeroUnitAbilitiesOfType(hero, ["Q", "W", "E"]).map(
        convertSkillTypeToSubtypeOf.bind(null, "D")
      );
    case "Chen": {
      const chenBofSkill = findAbilityById(hero, "ChenBreathOfFire", {
        skipHeroAbilities: true,
        skipHeroUnitAbilities: true,
        skipHeroUnitSubAbilities: true,
      });
      return [parseSkillTalent(chenBofSkill.en, chenBofSkill.ko)];
    }
    case "DVa":
      return parseHeroUnitAbilitiesOfType(hero, ["Trait", "E"]);
    case "Deathwing":
      return findAbilitiesByIds(
        hero,
        [
          "DeathwingLavaBurst",
          "DeathwingEarthShatter",
          "DeathwingDestroyerForm",
          "DeathwingWorldbreakerForm",
        ],
        { skipHeroUnitAbilities: true, skipHeroUnitSubAbilities: true }
      ).map(({ en, ko }) => {
        const skill = parseSkillTalent(en, ko);
        if (
          skill.id === "DeathwingDestroyerForm" ||
          skill.id === "DeathwingWorldbreakerForm"
        ) {
          convertSkillTypeToSubtypeOf("Z", skill);
        }
        return skill;
      });
    case "Fenix":
      return findAllAbilitiesByTypes(hero, ["W"], {
        skipHeroAbilities: true,
      }).map(({ en, ko }) => parseSkillTalent(en, ko));
    case "Greymane":
      return findAllAbilitiesByTypes(hero, ["Q", "E"], {
        skipHeroAbilities: true,
        skipHeroUnitAbilities: true,
        skipHeroUnitSubAbilities: true,
      }).map(({ en, ko }) =>
        convertSkillTypeToSubtypeOf("D", parseSkillTalent(en, ko))
      );
    case "Jaina":
    case "KelThuzad": {
      const abilities = findAllAbilitiesByTypes(hero, ["Active"], {
        skipHeroAbilities: true,
        skipHeroUnitAbilities: true,
        skipHeroUnitSubAbilities: true,
      });
      equal(abilities.length, 1, "Hero %o: unexpected number of active skills");
      return abilities.map(({ en, ko }) =>
        convertSkillTypeToSubtypeOf("D", parseSkillTalent(en, ko))
      );
    }
    case "Leoric":
      return findAllAbilitiesByTypes(hero, ["Q", "W"], {
        skipHeroAbilities: true,
        skipHeroUnitAbilities: true,
        skipHeroUnitSubAbilities: true,
      }).map(({ en, ko }) =>
        convertSkillTypeToSubtypeOf("D", parseSkillTalent(en, ko))
      );
    case "Uther": {
      const { en, ko } = findAbilityById(hero, "UtherFlashofLight", {
        skipHeroAbilities: true,
        skipHeroUnitAbilities: true,
        skipHeroUnitSubAbilities: true,
      });
      return [convertSkillTypeToSubtypeOf("D", parseSkillTalent(en, ko))];
    }
    case "Valeera":
      return findAllAbilitiesByTypes(hero, ["Q", "W", "E"], {
        skipHeroAbilities: true,
        skipHeroUnitAbilities: true,
        skipHeroUnitSubAbilities: true,
      }).map(({ en, ko }) =>
        convertSkillTypeToSubtypeOf("D", parseSkillTalent(en, ko))
      );
  }

  return [];
}

/**
 * Parses additional talents for a hero, and inserts them into `talents`.
 * @param {HeroPack} hero
 * @param {Record<string, Talent[]>} talents Talent collection to be updated
 *    in-place.
 */
function insertAdditionalTalents(hero, talents) {
  switch (hero.id) {
    case "Chen":
      insertAbilitiesAsTalentsAfter(
        findAbilitiesByIds(hero, ["ChenStorm", "ChenEarth", "ChenFire"]),
        talents,
        "ChenHeroicAbilityStormEarthFire"
      );
      break;
    case "Junkrat":
      insertAbilitiesAsTalentsAfter(
        [findAbilityById(hero, "JunkratRIPTireJump")],
        talents,
        "JunkratRIPTire"
      );
      break;
    case "Firebat": {
      // Currently, HeroesDataParser does not extract this ability.
      // Therefore we must manually generate it.
      const abilityId = "FirebatBunkerDropFlamethrower";
      throws(
        () => findAbilityById(hero, abilityId),
        "Hero %o has ability %o, we can use it now",
        hero.id,
        abilityId
      );

      const { talentArray, index } = findTalentById(
        talents,
        "FirebatHeroicAbilityBunkerDrop"
      );
      talentArray.splice(index + 1, 0, {
        id: "FirebatBunkerDropFlamethrower",
        name: { en: "Flamethrower", ko: "화염방사기" },
        type: "R - Q",
        icon: "storm_ui_icon_blaze_flame",
        description: "일직선상의 적들에게 170(+4%)의 피해를 줍니다.",
        shortDescription: "일직선상의 적들에게 피해를 줍니다.",
        cooldown: 1,
        extras: {
          사거리: 10,
          너비: 1.85,
        },
      });
      break;
    }
    case "LostVikings":
      insertAbilitiesAsTalentsAfter(
        [findAbilityById(hero, "LostVikingsLongboatRaidMortar")],
        talents,
        "LostVikingsHeroicAbilityLongboatRaid"
      );
      break;
    case "Tychus":
      insertAbilitiesAsTalentsAfter(
        findAbilitiesByIds(hero, [
          "TychusOdinAnnihilate",
          "TychusOdinRagnarokMissilesTargeted",
          "TychusOdinThrusters",
        ]),
        talents,
        "TychusHeroicAbilityCommandeerOdin"
      );
      break;
  }
}

/**
 * Converts HDP abilities to Talents, then inserts them into `talents` as the
 * child talents of talent specified by `talentId`.
 * @param {{ en: HdpAbilityEn, ko: HdpAbilityKo }[]} hdpAbilities
 * @param {Record<string, Talent[]>} talents Talent collection to update in-place
 * @param {string} parentTalentId ID of the parent talent
 */
function insertAbilitiesAsTalentsAfter(hdpAbilities, talents, parentTalentId) {
  const { talentArray, index } = findTalentById(talents, parentTalentId);
  const parentTalent = talentArray[index];

  talentArray.splice(
    index + 1,
    0,
    ...hdpAbilities.map(({ en, ko }) =>
      convertSkillTypeToSubtypeOf(parentTalent.type, parseSkillTalent(en, ko))
    )
  );
}

/**
 * Parses abilities from all hero units of a hero, using an array of ability
 * types.
 * Throws if an ability type cannot be found.
 * @param {HeroPack} hero
 * @param {HdpAbilityType[]} types
 * @return {Skill[]}
 */
function parseHeroUnitAbilitiesOfType(hero, types) {
  return findAllAbilitiesByTypes(hero, types, {
    skipHeroAbilities: true,
    skipHeroSubAbilities: true,
    skipHeroUnitSubAbilities: true,
  }).map((ability) => parseSkillTalent(ability.en, ability.ko));
}

const ABILITY_TYPE_TO_SKILL_TYPE = makeReadonlyMap({
  Trait: _c("D"),
  Q: _c("Q"),
  W: _c("W"),
  E: _c("E"),
  Heroic: _c("R"),
  Z: _c("Z"),
  Passive: _c("passive"),
  Active: _c("active"),
});

const CUSTOM_SHORT_TOOLTIPS = makeReadonlyMap({
  AbathurSymbioteCarapace: "아군에게 보호막 부여",
  DeathwingFormSwitch: "파괴자 또는 세계 파괴자로 형상 전환",
  DVaPilotCallMech: "메카를 호출하여 탑승하고 메카 모드로 전환",
  DVaPilotPilotMode:
    "일반 공격으로 메카 호출의 재사용 대기시간 감소, 사망 시 주는 경험치 감소",
  LeoricDrainEssence: "적 영웅 가까이 머무르는 동안 생명력 회복",
  LeoricGhastlySwing: "적들을 느려지게 함",
  LostVikingsLongboatRaidMortar: "넓은 지역에 피해를 줌",
  TychusOdinThrusters: "대상 방향으로 질주",
});

// eslint-disable-next-line valid-jsdoc -- TypeScript syntax
/**
 * Parses an ability (skill) or talent.
 * @param {HdpAbilityEn | HdpTalentEn} abilityEn
 * @param {HdpAbilityKo | HdpTalentKo} abilityKo
 * @return {Skill & Talent}
 * @throws {Error} If the talent has unexpected ability type
 */
export function parseSkillTalent(abilityEn, abilityKo) {
  equal(abilityEn.nameId, abilityKo.nameId);

  const skillType = ABILITY_TYPE_TO_SKILL_TYPE.get(abilityEn.abilityType);
  assert(
    isNotNullish(skillType),
    "Unexpected ability type: %o in %o",
    abilityEn.abilityType,
    abilityEn.nameId
  );

  // If shortTooltip is not available, add a custom tooltip
  let { shortTooltip } = abilityKo;
  if (isNullish(shortTooltip)) {
    shortTooltip = CUSTOM_SHORT_TOOLTIPS.get(abilityEn.nameId);
    assert(
      isNotNullish(shortTooltip),
      "Ability %o: missing short tooltip (value: %o)",
      abilityEn.nameId,
      abilityKo.shortTooltip
    );
  } else {
    console.assert(
      !CUSTOM_SHORT_TOOLTIPS.has(abilityEn.nameId),
      "%o has a custom shortTooltip, but a shortTooltip already exists",
      abilityEn.nameId
    );
  }

  let description = parseTooltip(abilityKo.fullTooltip);

  // Fix tooltip errors
  if (abilityEn.nameId === "AnaShrikeVampiricRounds") {
    // TODO: Find out if this is caused by a bug in HeroesDataParser or HotS.
    description = description.replace(
      "독극물 5중첩을 달성하면 때까치의 치유량이 0.25% 증가합니다.",
      "독극물 5중첩을 달성하면 때까치의 치유량이 0.75% 증가합니다."
    );
  }

  let cooldownFragment;
  switch (abilityEn.nameId) {
    case "AnubarakLegionOfBeetlesVisual":
    case "DVaPilotCallMechMEKAfall":
    case "FalstadTailwindCooldownDisplay":
    case "ThrallSpiritShield":
      // Skip parsing cooldown tooltips for abilities that erroneously have them
      console.assert(
        isNotNullish(abilityEn.cooldownTooltip),
        "Bug is fixed for %o, maybe we can delete this check now?",
        abilityEn.nameId
      );
      break;
    // Manually add cooldowns to abilities that erroneously do not have
    // cooldown tooltips
    case "WizardArchonPurePower":
      assert(
        isNullish(abilityEn.cooldownTooltip),
        "Bug is fixed for %o, we should delete this check if possible",
        abilityEn.nameId
      );
      cooldownFragment = { cooldown: 10 };
      break;
    default:
      cooldownFragment = extractCooldownFragment(abilityEn.cooldownTooltip);
  }

  // Some abilities erroneously have "Cooldown: XX seconds" even though they
  // actually hold multiple charges. Thus, we have to manually check if the
  // skill has multiple charges.
  if (
    abilityEn.charges &&
    abilityEn.charges.countStart &&
    abilityEn.charges.countStart > 1
  ) {
    // If a skill does not have a cooldownTooltip at all, the countStart is
    // probably a dud.
    // However, the skill may have a cooldownTooltip which erroneously claims
    // that it does NOT have charges. This is the exceptional case we are
    // looking for.
    if (cooldownFragment && !cooldownFragment.rechargeCooldown) {
      console.warn(
        "Ability %o has %d charges, although cooldownTooltip says otherwise: %o",
        abilityEn.nameId,
        abilityEn.charges.countStart,
        abilityEn.cooldownTooltip
      );
      assert(cooldownFragment.cooldown, "Expected cooldown but found none");
      assert(!cooldownFragment.cooldownPerAlly, "Unexpected cooldownPerAlly");
      // Replace with recharge cooldown
      cooldownFragment = { rechargeCooldown: cooldownFragment.cooldown };
    }
  }

  let abilityCostFragment;
  if (isNotNullish(abilityEn.energyTooltip)) {
    abilityCostFragment = extractAbilityCostFragment(abilityEn.energyTooltip);
    switch (abilityEn.nameId) {
      // HeroesDataParser erroneously believes that Deathwing's abilities spend
      // Mana, not Energy. Thus, we have to fix this manually.
      case "DeathwingMoltenFlame":
        assert(
          abilityCostFragment.manaCost,
          "Bug seems to be fixed. Maybe we can delete this check?"
        );
        abilityCostFragment = {
          extras: { 기력: abilityCostFragment.manaCost },
        };
    }
  }

  let icon = iconNameToId(abilityEn.icon);
  // The "empty" Blink icon is ugly; we'll use the "full" icon instead.
  if (icon === "storm_ui_icon_tracer_blink_empty") {
    icon = "storm_ui_icon_tracer_blink";
  }

  // Fix for Lucio's Crossfade: Needed because HeroesDataParser does not
  // extract the "combined" dummy skill shown in the in-game Hero shop.
  // TODO: Maybe we should just use the two separate in-game abilities instead?
  // (Healing Boost and Speed Boost)
  if (abilityEn.nameId === "LucioCrossfade") {
    icon = "storm_ui_icon_lucio_crossfade_all";
    description =
      "자신과 주위 아군에게 두 가지 곡 중 하나를 들려줍니다." +
      '\n\n<span style="color:#fff800">치유 증폭</span>: 자신과 주위 아군 영웅들의 생명력을 초당 16(+4%) 회복시킵니다.' +
      '\n\n<span style="color:#3dff7f">속도 증폭</span>: 자신과 주위 아군 영웅들의 이동 속도가 10% 증가합니다.';
  }

  return {
    id: abilityEn.nameId,
    name: {
      en: abilityEn.name.trim(),
      ko: abilityKo.name.trim(),
    },
    type: skillType,
    icon,
    description,
    shortDescription: parseShortTooltip(shortTooltip),
    ...cooldownFragment,
    ...abilityCostFragment,
  };
}

/**
 * Parses a talent.
 * @param {HdpAbilityEn | HdpTalentEn} talentEn
 * @param {HdpAbilityEn | HdpTalentKo} talentKo
 * @return {Talent}
 */
export function parseTalent(talentEn, talentKo) {
  /** @type {Talent} */
  const talent = parseSkillTalent(talentEn, talentKo);

  talent.type = getUpdatedTalentType(talent, talentEn);
  const upgradeFor = getTalentUpgradeFor(talent, talentEn);
  if (isNotNullish(upgradeFor)) talent.upgradeFor = upgradeFor;

  return talent;
}

/**
 * Corrects the talent type.
 * @param {Readonly<Talent>} talent
 * @param {Readonly<HdpAbilityEn | HdpTalentEn>} talentEn
 * @return {SkillType}
 */
function getUpdatedTalentType(talent, talentEn) {
  // Note: Some active abilities and talents do not have cooldowns, e.g. Bribe.
  // It is better to rely on talentEn.isActive than directly checking cooldowns.

  switch (talent.type) {
    case "active":
      switch (talent.id) {
        // Incorrectly classified as talentEn.abilityType === "Active"
        case "GarroshArmorUpSeasonedSoldier":
        case "GarroshArmorUpInnerRage":
        case "Zul'jinAmaniRageAmaniHide":
          return "passive";
        case "LostVikingsMasterySpinToWin":
        case "LostVikingsMasteryNorseForce":
          return "Q";
        case "LostVikingsMasteryJump":
          return "W";
        case "LostVikingsMasteryVikingBribery":
          return "E";
      }
    // fall through
    case "passive":
      // Use current talent type (passive/active)
      return talent.type;
    case "R":
      switch (talent.id) {
        // Alarak can unlock his other heroic ability at Lv20, assigned to D key
        case "AlarakCounterStrikeItem":
        case "AlarakDeadlyChargeSecondHeroic":
          return "D";
        // Passive heroics
        case "VarianTwinBladesOfFury":
          return "R";
      }
      break;
    case "D":
      switch (talent.icon) {
        // Passives that unlock a Trait
        case "storm_ui_icon_monk_trait_transcendence":
        case "storm_ui_icon_monk_trait_ironfist":
        case "storm_ui_icon_monk_trait_insight":
          return talent.type;
        // Talents that make a passive Trait clickable
        case "storm_ui_icon_muradin_secondwind":
        case "storm_ui_icon_orphea_trait":
        case "storm_ui_icon_sonya_fury":
        case "storm_ui_icon_stitches_acidcloud":
        case "storm_ui_icon_alarak_sadism_b":
          return talentEn.isActive ? "active" : "passive";
      }
      break;
    case "E":
      if (talent.id === "DeathwingSkyfall") return "Z - E";
      if (talent.id === "DVaPilotCallMechMEKAfall") return "passive";
      break;
    case "Q":
    case "W":
    case "Z":
      break;
    default:
      fail("Talent %o has unexpected type: %o", talent.id, talent.type);
  }

  // If we reach here, assume that:
  // - All active talents are unlocks.
  // - All passive talents are upgrades.
  return talentEn.isActive ? talent.type : "passive";
}

/**
 * @param {Readonly<Talent>} talent
 * @param {Readonly<HdpAbilityEn | HdpTalentEn>} talentEn
 * @return {UpgradeForType | undefined}
 */
function getTalentUpgradeFor(talent, talentEn) {
  switch (talent.type) {
    case "R":
      return undefined;
    case "Q":
    case "W":
    case "Z - E":
      // These talents are not upgrades if they are active
      if (talentEn.isActive) return undefined;
  }

  // Check for exceptions
  // Use the talent icon to determine hybrid talents, or talents that
  // upgrade child abilities.
  // This is a very ad-hoc method, but it works for us.
  switch (talent.icon) {
    case "storm_ui_icon_valeera_ambush":
      return "D - Q";
    case "storm_ui_icon_valeera_cheapshot":
      return "D - W";
    case "storm_ui_icon_valeera_garrote":
      return "D - E";
    case "storm_ui_icon_abathur_stab":
      return "Q - Q";
    case "storm_ui_icon_abathur_spikeburst":
      return "Q - W";
    case "storm_ui_icon_abathur_carapace":
      return "Q - E";
    case "storm_ui_icon_deathwing_destroyer":
      return "Z - Q";
    case "storm_ui_icon_deathwing_deathdrop":
    case "storm_ui_icon_deathwing_firestorm":
      return "Z - Q / Z - W";
    case "storm_ui_icon_tracer_combo_q_trait":
      return "D / Q";
    case "storm_ui_icon_cassia_combo_q_w":
    case "storm_ui_icon_malfurion_wildgrowth_a":
    case "storm_ui_icon_malfurion_wildgrowth":
    case "storm_ui_icon_raynor_split_fuelrush":
      return "Q / W";
    case "storm_ui_icon_cassia_combo_q_e":
    case "storm_ui_icon_diablo_combo_1":
      return "Q / E";
    case "storm_ui_icon_tracer_combo_q_r":
      return "Q / R";
    case "storm_ui_icon_junkrat_trap_mine":
    case "storm_ui_icon_maiev_pursuit_vengeance":
    case "storm_ui_icon_raynor_split_debilitatingrounds":
    case "storm_ui_icon_tyrael_zealous_conviction":
    case "storm_ui_icon_whitemane_inquisition_lash":
      return "W / E";
    case "storm_ui_icon_tracer_combo_e_r":
      return "E / R";
    // Incorrectly assigned talentEn.abilityType === "Trait"
    case "storm_ui_icon_lostvikings_fastrestart":
    case "storm_ui_icon_probius_shieldcapacitor":
    // Passives that unlock a trait, not upgrade it
    // fall through
    case "storm_ui_icon_monk_trait_transcendence":
    case "storm_ui_icon_monk_trait_ironfist":
    case "storm_ui_icon_monk_trait_insight":
      return undefined;
    // Talents that do not have a proper talentEn.abilityType
    case "storm_ui_icon_anubarak_scarabhost":
    case "storm_ui_icon_cassia_avoidance":
    case "storm_ui_icon_fenix_shield_1":
    case "storm_ui_icon_malganis_trait_b":
    case "storm_ui_icon_malganis_trait":
    case "storm_ui_icon_mephisto_hatred":
    case "storm_ui_icon_samuro_flowingstrikes":
      return "D";
    case "storm_ui_icon_malganis_blindbat":
    case "storm_ui_icon_orphea_reset":
      return "Q";
    case "storm_ui_icon_leoric_drainhope":
      return "W";
    case "storm_ui_icon_brightwing_pixiedust":
    case "storm_ui_icon_medivh_portal":
    case "storm_ui_icon_mephisto_shade":
      return "E";
    case "storm_ui_icon_varian_twinbladesoffury":
      return "R";
    case "storm_ui_icon_lostvikings_selectbaleog":
    case "storm_ui_icon_lostvikings_selecterik_var1":
    case "storm_ui_icon_lostvikings_selecterik":
    case "storm_ui_icon_lostvikings_selectolaf":
      return "passive";
    case "storm_ui_icon_gall_eyeofkilrogg":
    case "storm_ui_icon_kel'thuzad_glacialspike":
    case "storm_ui_icon_necromancer_bonearmor_b":
    case "storm_ui_icon_necromancer_bonearmor_c":
    case "storm_ui_icon_necromancer_bonearmor":
    case "storm_ui_icon_varian_glorytothealliance":
    case "storm_ui_icon_zeratul_vorpalblade":
    case "storm_ui_icon_zuljin_davoodooshuffle":
      return "active";
    default:
      // Talents that cannot be selected via icons, because they share icons
      // with other talents with different 'upgradeFor'
      if (talent.id === "BrightwingMagicSpit") {
        return "D";
      }
      if (talent.id === "GarroshArmorUpInnerRage") {
        return "active";
      }
      if (talent.id === "ZaryaWeaponFeelTheHeat") {
        return undefined;
      }
  }

  // If we reach here, assume that all abilityTypes other than Passive and
  // Active are upgrades
  const upgradeFor = ABILITY_TYPE_TO_SKILL_TYPE.get(talentEn.abilityType);
  assert(
    isNotNullish(upgradeFor),
    "Unexpected ability type: %o in %o",
    talentEn.abilityType,
    talentEn.nameId
  );

  if (upgradeFor === "active" || upgradeFor === "passive") {
    return undefined;
  }
  return upgradeFor;
}

/**
 * Converts an icon's file name to an icon ID.
 * @param {string} fileName
 * @return {string}
 */
function iconNameToId(fileName) {
  return fileName.replace(/\.\w+$/, "");
}

/**
 * Searches for a talent by ID. Upon success, returns its containing array
 * (`talentArray`) and position in the array (`index`).
 * @param {Record<string, Talent[]>} talents
 * @param {string} talentId
 * @return {{ talentArray: Talent[], index: number }}
 * @throws If the talent cannot be found
 */
function findTalentById(talents, talentId) {
  const talentArrayArray = Object.values(talents);
  for (const talentArray of talentArrayArray) {
    const index = talentArray.findIndex((talent) => talent.id === talentId);
    if (index !== -1) return { talentArray, index };
  }

  assert(
    talentArrayArray.length !== 0,
    "Cannot find talent %o because talent record is empty",
    talentId
  );
  fail("Cannot find talent %o", talentId);
}

// eslint-disable-next-line valid-jsdoc -- TypeScript syntax
/**
 * Creates a Map from an object, typed as a ReadonlyMap.
 * @template {Record<any, any>} T
 * @param {T} obj
 * @return {ReadonlyMap<string, T[keyof T]>}
 */
function makeReadonlyMap(obj) {
  return new Map(Object.entries(obj));
}
