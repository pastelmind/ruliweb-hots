/**
 * @file Tools for searching JSON data generated by HeroesDataParser.
 *
 * Functions in this file can be grouped into two categories.
 *
 * - findXXX():
 *    Accepts composite HDP hero objects (with fields 'id', 'en', 'ko'),
 *    and returns composite HDP ability objects (with fields 'en', 'ko').
 * - lookupXXX():
 *    Accepts a single HDP hero object (en or ko) and returns a single HDP
 *    ability object (en or ko).
 */

import { assert, equal, fail } from "./lazy-assert.js";

/**
 * @typedef {import("../../generated-types/hdp-herodata-ko").AbilityKo} HdpAbilityKo
 * @typedef {import("../../generated-types/hdp-herodata-ko").HeroKo} HdpHeroKo
 * @typedef {import("../../generated-types/hdp-herodata").Ability} HdpAbilityEn
 * @typedef {import("../../generated-types/hdp-herodata").AbilityType} HdpAbilityType
 * @typedef {import("../../generated-types/hdp-herodata").Hero} HdpHeroEn
 */

/**
 * @typedef {object} AbilityFindOptions
 * @property {boolean} [skipHeroAbilities]
 *    If truthy, ignore the abilities of the hero itself (default `false`).
 * @property {boolean} [skipHeroSubAbilities]
 *    If truthy, ignore the sub-abilities of the hero itself (default `false`).
 * @property {boolean} [skipHeroUnitAbilities]
 *    If truthy, ignore the abilities of the hero's hero units
 *    (default `false`).
 * @property {boolean} [skipHeroUnitSubAbilities]
 *    If truthy, ignore the sub-abilities of the hero's hero units
 *    (default `false`).
 * @property {boolean} [allowDuplicateIds]
 *    If truthy, the function will not skip abilities with duplicate IDs
 *    (default `false`).
 */

/**
 * Searches the hero for the ability matching the given ID.
 * Throws if the ability cannot be found.
 * @param {{ id: string, en: HdpHeroEn, ko: HdpHeroKo }} hero
 * @param {string} id
 * @param {AbilityFindOptions} [options] Search options
 * @return {{ en: HdpAbilityEn, ko: HdpAbilityKo }}
 */
export function findAbilityById(hero, id, options) {
  const abilityEn = lookupAbility(hero.en, (a) => a.nameId === id, options);
  assert(abilityEn, "Cannot find ability %o in hero %o (en)", id, hero.id);

  const abilityKo = lookupAbility(hero.ko, (a) => a.nameId === id, options);
  assert(abilityKo, "Cannot find ability %o in hero %o (ko)", id, hero.id);

  return { en: abilityEn, ko: abilityKo };
}

/**
 * Searches the hero for abilities matching a list of ability IDs.
 * @param {{ id: string, en: HdpHeroEn, ko: HdpHeroKo }} hero
 * @param {string[]} abilityIds Array of ability IDs. Duplicates are ignored.
 * @param {AbilityFindOptions} [options] Search options
 * @return {{ en: HdpAbilityEn, ko: HdpAbilityKo }[]}
 *    Unordered array of abilities
 * @throws If an ability ID cannot be found
 */
export function findAbilitiesByIds(hero, abilityIds, options) {
  const abilitiesEn = lookupAbilitiesByIds(hero.en, abilityIds, options);
  const abilitiesKo = lookupAbilitiesByIds(hero.ko, abilityIds, options);
  return packAbilities(abilitiesEn, abilitiesKo, hero.id, abilityIds);
}

/**
 * Finds all abilities of a hero that match any of the given ability types.
 * @param {{ id: string, en: HdpHeroEn, ko: HdpHeroKo }} hero
 * @param {HdpAbilityType[]} types Ability types
 * @param {AbilityFindOptions} [options] Search options
 * @return {{ en: HdpAbilityEn, ko: HdpAbilityKo }[]}
 *    Unordered array of abilities
 * @throws If an ability type cannot be found
 */
export function findAllAbilitiesByTypes(hero, types, options) {
  const abilitiesEn = lookupAbilitiesByTypes(hero.en, types, options);
  const abilitiesKo = lookupAbilitiesByTypes(hero.ko, types, options);
  return packAbilities(abilitiesEn, abilitiesKo, hero.id, types);
}

/**
 * @template T
 * @typedef {Partial<Record<string, T[]>>} HdpAbilityRecordGeneric
 */

/**
 * @template T
 * @typedef {object} HdpHeroUnitGeneric
 * @property {string} name
 * @property {string} hyperlinkId
 * @property {HdpAbilityRecordGeneric<T>} abilities
 * @property {Record<string, HdpAbilityRecordGeneric<T>>[]=} subAbilities
 */

/**
 * @template T
 * @typedef {object} HdpHeroGeneric
 * @property {string} name
 * @property {string} unitId
 * @property {string} hyperlinkId
 * @property {HdpAbilityRecordGeneric<T>} abilities
 * @property {Record<string, HdpHeroUnitGeneric<T>>[]=} heroUnits
 * @property {Record<string, HdpAbilityRecordGeneric<T>>[]=} subAbilities
 */

/**
 * Callback that tests an ability object.
 * @template T
 * @callback AbilityFindCallback
 * @param {T} ability Current ability.
 * @param {HdpHeroGeneric<T> | HdpHeroUnitGeneric<T>} owner
 *    Hero or hero unit that directly owns the ability. If the current ability is owned
 *    directly by the hero, this is identical to `hero`.
 * @param {HdpHeroGeneric<T>} hero Hero that (in)directly owns the ability.
 * @return {*}
 */

/**
 * Traverses a HdpHero object, applying the callback to each ability.
 * If the callback returns a truthy value, stops the search and returns the
 * current ability.
 * When the search ends, returns `undefined`.
 *
 * This function does NOT check duplicate ability IDs.
 * @template {HdpAbilityEn | HdpAbilityKo} T
 * @param {HdpHeroGeneric<T> | HdpHeroUnitGeneric<T>} heroOrUnit
 * @param {HdpHeroGeneric<T>} hero
 * @param {AbilityFindCallback<T>} callback Callback to test each item with
 * @param {AbilityFindOptions} [options] Search options
 * @return {T | undefined} Ability that satisfies the callback, or `undefined`
 */
function lookupHeroOrUnitAbility(heroOrUnit, hero, callback, options = {}) {
  // Search abilities on the hero itself
  if (!options.skipHeroAbilities) {
    for (const abilityArray of Object.values(heroOrUnit.abilities)) {
      if (!abilityArray) continue;
      for (const ability of abilityArray) {
        if (callback(ability, heroOrUnit, hero)) return ability;
      }
    }
  }

  // Search subabilities
  if (!options.skipHeroSubAbilities) {
    for (const subAbilityGroup of heroOrUnit.subAbilities || []) {
      for (const abilityRecord of Object.values(subAbilityGroup)) {
        for (const abilityArray of Object.values(abilityRecord)) {
          if (!abilityArray) continue;
          for (const ability of abilityArray) {
            if (callback(ability, heroOrUnit, hero)) return ability;
          }
        }
      }
    }
  }

  // Search abilities on the hero units
  if (
    !(options.skipHeroUnitAbilities && options.skipHeroUnitSubAbilities) &&
    "heroUnits" in heroOrUnit
  ) {
    // Create separate options object for hero units.
    /** @type {AbilityFindOptions} */
    const opts = {
      skipHeroAbilities: options.skipHeroUnitAbilities,
      skipHeroSubAbilities: options.skipHeroUnitSubAbilities,
    };

    for (const heroUnitGroup of heroOrUnit.heroUnits || []) {
      for (const [heroUnitId, heroUnit] of Object.entries(heroUnitGroup)) {
        equal(
          heroUnitId,
          heroUnit.hyperlinkId,
          "Hero unit ID does not match its hyperlinkId"
        );
        const ability = lookupHeroOrUnitAbility(heroUnit, hero, callback, opts);
        if (ability) return ability;
      }
    }
  }

  return undefined;
}

/**
 * Returns the first ability that satisfies the callback.
 * @template {HdpAbilityEn | HdpAbilityKo} T
 * @param {HdpHeroGeneric<T>} hero
 * @param {AbilityFindCallback<T>} callback Callback to test each item with
 * @param {AbilityFindOptions} [options] Search options
 * @return {T | undefined} If successful, the ability found
 */
function lookupAbility(hero, callback, options = {}) {
  if (options.allowDuplicateIds) {
    return lookupHeroOrUnitAbility(hero, hero, callback, options);
  }

  /** @type {Set<string>} */
  const abilityIdsSeen = new Set();
  return lookupHeroOrUnitAbility(
    hero,
    hero,
    (ability, ...rest) => {
      // Exploit the fact that all expressions are evaluated right-to-left.
      // If the ability ID was already seen, both sides would be equal.
      // If not, the ID is added to the set, making the left and right unequal.
      if (abilityIdsSeen.size !== abilityIdsSeen.add(ability.nameId).size) {
        return callback(ability, ...rest);
      }
      // Implicitly return 'undefined' to keep searching
    },
    options
  );
}

/**
 * Returns all abilities that satisfy the callback.
 * @template {HdpAbilityEn | HdpAbilityKo} T
 * @param {HdpHeroGeneric<T>} hero
 * @param {AbilityFindCallback<T>} callback Callback to test each item with.
 * @param {AbilityFindOptions} [options] Search options
 * @return {T[]}
 */
function lookupAllAbilities(hero, callback, options) {
  /** @type {T[]} */
  const abilities = [];

  lookupAbility(
    hero,
    (ability, ...rest) => {
      if (callback(ability, ...rest)) abilities.push(ability);
      // Implicitly return 'undefined' to keep searching
    },
    options
  );

  return abilities;
}

/**
 * Returns abilities matching a list of ability IDs.
 * @template {HdpAbilityEn | HdpAbilityKo} T
 * @param {HdpHeroGeneric<T>} hero
 * @param {string[]} abilityIds Array of ability IDs. Duplicates are ignored.
 * @param {AbilityFindOptions} [options] Search options
 * @return {T[]} Array of abilities in the order they were found
 * @throws If an ability ID cannot be found
 */
function lookupAbilitiesByIds(hero, abilityIds, options) {
  /** @type {T[]} */
  const abilities = [];
  const notFoundIds = new Set(abilityIds);

  // Use lookupAbility() to short-circuit the search if all IDs are found
  lookupAbility(
    hero,
    (ability) => {
      if (notFoundIds.delete(ability.nameId)) {
        abilities.push(ability);
        return notFoundIds.size === 0; // Continue until all IDs are found
      }
      return false; // Keep searching
    },
    options
  );

  if (notFoundIds.size > 0) {
    fail(
      "Cannot find ability ID(s) %o in hero name %o",
      [...notFoundIds],
      hero.name
    );
  }

  return abilities;
}

/**
 * Returns all abilities matching any of the given ability types.
 * @template {HdpAbilityEn | HdpAbilityKo} T
 * @param {HdpHeroGeneric<T>} hero
 * @param {HdpAbilityType[]} types Ability types
 * @param {AbilityFindOptions} [options] Search options
 * @return {T[]} Array of abilities in the order they were found
 * @throws If an ability type cannot be found
 */
function lookupAbilitiesByTypes(hero, types, options) {
  const typesToFind = new Set(types);

  const abilities = lookupAllAbilities(
    hero,
    (ability) => typesToFind.has(ability.abilityType),
    options
  );

  for (const ability of abilities) {
    typesToFind.delete(ability.abilityType);
  }

  if (typesToFind.size > 0) {
    fail(
      "Cannot find ability type(s) %o in hero name %o",
      [...typesToFind],
      hero.name
    );
  }

  return abilities;
}

/**
 * @param {HdpAbilityEn[]} abilitiesEn
 * @param {HdpAbilityKo[]} abilitiesKo
 * @param {string} heroId
 * @param {any[]} rest
 * @return {{ en: HdpAbilityEn, ko: HdpAbilityKo }[]}
 */
function packAbilities(abilitiesEn, abilitiesKo, heroId, ...rest) {
  equal(
    abilitiesEn.length,
    abilitiesKo.length,
    "Array lengths differ in %o while searching for",
    heroId,
    ...rest
  );

  return abilitiesEn.map((abilityEn, index) => {
    const abilityKo = abilitiesKo[index];
    equal(
      abilityEn.nameId,
      abilityKo.nameId,
      "Mismatching ability found in %o while searching for",
      heroId,
      ...rest
    );
    return { en: abilityEn, ko: abilityKo };
  });
}
