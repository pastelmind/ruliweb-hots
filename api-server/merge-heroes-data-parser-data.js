#!/usr/bin/env node
'use strict';

/**
 * Merge data from JSON files generated by [HeroesDataParser](https://github.com/koliva8245/HeroesDataParser)
 * into ruliweb-hots' own JSON file.
 * Note: To use HeroesDataParser, you should use the `-l koKR` option.
 */

const fs = require('fs');
const path = require('path');
const util = require('util');
const program = require('commander');

const HotsData = require('./src/hots-data');


const readFileAsync = util.promisify(fs.readFile);
const writeFileAsync = util.promisify(fs.writeFile);


//Compatibility code for Node v8
require('./src/console-assert-no-throw');


const DEFAULT_JSON_PATH = path.join(__dirname, '../docs/hots.json');


program
  .option('-d, --data-json <jsonfile>', 'JSON file generated by HeroesDataParser')
  .option('-i, --input-json [jsonfile]', 'Source JSON file to read from', DEFAULT_JSON_PATH)
  .option('-o, --output-json [jsonfile]', 'Target JSON file to write to', DEFAULT_JSON_PATH)
  .parse(process.argv);


if (process.argv.length <= 2 || !program.dataJson) {
  console.error('Must specify HeroesDataParser JSON file path');
  program.help();
}


(async () => {
  program.inputJson = path.resolve(program.inputJson);
  console.log('Reading input JSON from', program.dataJson);
  const hotsData = new HotsData(await readFileAsync(program.inputJson, 'utf8'));

  program.dataJson = path.resolve(program.dataJson);
  console.log('Reading HeroesDataParser JSON from', program.dataJson);
  const dataJson = JSON.parse(await readFileAsync(program.dataJson, 'utf8'));

  for (const heroDataName in dataJson) {
    console.log('Merging entry:', heroDataName);
    mergeHeroData(hotsData, dataJson[heroDataName]);
  }

  program.outputJson = path.resolve(program.outputJson);
  await writeFileAsync(program.outputJson, hotsData.stringify());
  console.log('HotS data saved to', program.outputJson);
})();


//-------- Support functions --------//

/**
 * Merge the given hero data into the HotsData object.
 * @param {HotsData} hotsData
 * @param {Object} heroJson
 */
function mergeHeroData(hotsData, heroJson) {
  const hero = hotsData.allHeroes().find(hero => hero.name === heroJson.name);
  if (!hero) {
    console.warn('Cannot find hero with name:', heroJson.name);
    return;
  }

  for (const skill of hero.skills) {
    const skillData = findSkillData(heroJson, skill);

    if (skillData) {
      //Extract short description
      if (skillData.shortTooltip)
        skill.shortDescription = parseTooltip(skillData.shortTooltip);
      else
        console.warn(`${skillData.name} is missing a short tooltip`);
    }
    else
      console.warn('Cannot find skill data matching', skill.name.ko);
  }

  for (const talent of hero.allTalents()) {
    const talentData = findTalentData(heroJson, talent);
    if (talentData) {
      //Extract short description
      if (talentData.shortTooltip)
        talent.shortDescription = parseTooltip(talentData.shortTooltip);
      else
        console.warn(`${talentData.name} is missing a short tooltip`);
    }
    else
      console.warn('Cannot find talent data matching', talent.name.ko);
  }
}


/**
 * Find a skill data entry in a hero data JSON that matches the given skill.
 * @param {Object} heroJson
 * @param {import("./src/skill")} skill
 * @return {Object} Skill data object if found, or undefined otherwise
 */
function findSkillData(heroJson, skill) {
  for (const abilityArray of Object.values(heroJson.abilities)) {
    const skillData = abilityArray.find(skillData => skillData.name.trim() === skill.name.ko);
    if (skillData) return skillData;
  }

  if (heroJson.subAbilities) {
    for (const subAbilitySuperGroup of heroJson.subAbilities) {
      for (const subAbilityGroup of Object.values(subAbilitySuperGroup)) {
        for (const abilityArray of Object.values(subAbilityGroup)) {
          const skillData = abilityArray.find(skillData => skillData.name.trim() === skill.name.ko);
          if (skillData) return skillData;
        }
      }
    }
  }

  if (heroJson.HeroUnits) {
    for (const heroUnitData of heroJson.HeroUnits) {
      for (const heroUnit of Object.values(heroUnitData)) {
        for (const abilityArray of Object.values(heroUnit.abilities || {})) {
          const skillData = abilityArray.find(skillData => skillData.name.trim() === skill.name.ko);
          if (skillData) return skillData;
        }
      }
    }
  }

  return undefined;
}


/**
 * Find a talent data entry in a hero data JSON that matches the given talent.
 * @param {Object} heroJson
 * @param {import("./src/talent")} talent
 * @return {Object} Talent data object if found, or undefined otherwise
 */
function findTalentData(heroJson, talent) {
  const talentLevelPropertyName = 'level' + ({
    2: 4,
    5: 7,
    8: 10,
    11: 13,
    14: 16,
    18: 20
  }[talent.level] || talent.level);

  const talentData = heroJson.talents[talentLevelPropertyName].find(talentData => talentData.name.trim() === talent.name.ko);
  if (talentData) return talentData;

  if (heroJson.subAbilities) {
    for (const subAbilitySuperGroup of heroJson.subAbilities) {
      for (const subAbilityGroup of Object.values(subAbilitySuperGroup)) {
        for (const abilityArray of Object.values(subAbilityGroup)) {
          const talentData = abilityArray.find(talentData => talentData.name.trim() === talent.name.ko);
          if (talentData) return talentData;
        }
      }
    }
  }

  if (heroJson.HeroUnits) {
    for (const heroUnitData of heroJson.HeroUnits) {
      for (const heroUnit of Object.values(heroUnitData)) {
        for (const abilityArray of Object.values(heroUnit.abilities || {})) {
          const talentData = abilityArray.find(talentData => talentData.name.trim() === talent.name.ko);
          if (talentData)
            return talentData;
        }
      }
    }
  }

  return undefined;
}

/**
 * Parse tooltip text, removing game data tags.
 * @param {string} tooltip
 */
function parseTooltip(tooltip) {
  return tooltip
    .replace(/<c val=".*?">/g, '')
    .replace(/<\/c>/g, '')
    .replace(/<n\/>/g, '\n')
    .replace(/<img.*?\/>/g, '')
    .trim();
}